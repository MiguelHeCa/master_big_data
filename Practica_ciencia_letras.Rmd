---
title: "Practica ciencias y letras"
author: "Miguel Hernández"
output: 
  html_document:
    toc: true
    toc_float: true
bibliography: ref/refm3.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Análisis factorial

Se usará la TMMS-24, en la que se mide la inteligencia emocional. Se ha recogido información de 130 estudiantes de Salamanca.

salovey mayer goldman tuvey & Palfai 1995
Fernández-berrocal, extremera y ramos (2004)

Mide tres factores:

1. Atención emocional. Capaz dde sentir y expresar los sentimientos de forma adecuada
2. Claridad emocional. Comprende bien sus estados emocionales
3. Reparación emocional. Es capaz de regular los estados emocionales correctamente

24 preguntas.
1. 1:8, 2. 9:16, 3. 17:24

## 0

Importe de la base de datos en R y compruebe que la importación es correcta.

```{r}
# Para cargarlo vía excel

tmms = readxl::read_excel("M3/T1/Tecnicas factoriales en R/TMMS Tecnicas factoriales.xlsx",
                          range = "B1:Y137")

# Carga de datos tmms con .RData
load("tmms.RData")

# Exploración del elemento
str(tmms)

# Respondieron
nrow(tmms)

# Variables
ncol(tmms)
```


## 1

Analice la información de la matriz de correlaciones. ¿Qué sentido tiene el valor de su determinante?

```{r}
cor_tmms = cor(tmms)

cor_tmms
```

Esta matriz es difícil de interpretar. Graficaremos la correlación, para ello usaremos el paquete `corrplot`

```{r}
# install.packages("corrplot")
library(corrplot)
```

Entonces usamos la función `corrplot()`

```{r}
corrplot(cor_tmms)
```

También se puede hacer calculando el determinante de las correlaciones con la función `det()`. Si es cercano a 0, significa que hay relación entre las variables.

```{r}
det(cor_tmms)
```

## 2

*Analice, mediante la prueba de esfericidad de Barlett y la medida KMO, si el modelo factorial es, o no, adecuado a los datos. Interprételo.*

La esfericidad completa tiene la forma:

$$
\begin{pmatrix}
  1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  0 & 0 & \cdots & 1 
 \end{pmatrix}
$$

Usaremos el paquete `psych` y el paquete inherente a R `stats`. Usaremos la matriz de correlaciones dentro de la función `cortest.bartlett()`.

```{r}
n_tmms = nrow(tmms)
psych::cortest.bartlett(cor_tmms, n_tmms)
```

El p-valor dió significativo, esto significa que no hay esfericidad.

Ahora, con la función `KMO()` usando directamente la matriz.

```{r}
psych::KMO(tmms)
```

Recordar que:

$$
\begin{align*}
\mathrm{KMO} &\geq 0.75 \Rightarrow \mathrm{Bien} \\
\mathrm{KMO} &\geq 0.5 \Rightarrow \mathrm{Aceptable} \\
\mathrm{KMO} &< 0.5 \Rightarrow \mathrm{Inaceptable}
\end{align*}
$$

El test KMO señala un coeficiente mayor que 0.75, así que es correcto seguir con el análisis de factores.

## 3

*Obtenga el scree-plot y explique la información que proporciona, así como la forma en que debe ser analizada.*

Ejes como el 75% de la información en ejes. Seleccionar como valores propios. Otro criterio es usar tantos ejes como estén arriba de valores propios mayor a 1.

Usaremos la función `scree()`. En `?scree` nos señala que podemos usar tanto la matriz de correlaciones como la de correlaciones.

```{r}
psych::scree(tmms)
```

Con la regla del codo se quedarían 4 factores. Con la regla del eigen value, nos quedamos con 3. 

Nuestro objetivo es buscar la estructura factorial de las tres dimensiones.

## 4

*Implemente el AF sin rotación. Obtenga los valores propios y el % de varianza explicada por cada uno de los facotres.*

Usaremos las funciones `factanal()` de `stats`. Queremos las matrices de saturaciones, puntuaciones factoriales y varianzas.

```{r}
af1 = factanal(tmms, 3, scores = "Bartlett", rotation = "none")

af1
```

`Uniqueness` son las unicidades. `Loadings` en AF se llaman **cargas**, en ACP se llaman **cargas**.




## 5

Del análisis del scree-plot y el listado de valores propios, indique el nº de factores que opina que se deben retener en el análisis para este caso concreto según los diversos criterios existentes. Señale cuál o cuáles de los criterios pueden ser aquí útiles y por qué.

Tres factores


## 6

Analice finalmente la estructura de la matriz de configuración o matriz de saturaciones para el análisis factorial. ¿Qué estructura puede adivinarse para la TMMS a partir de los resultados obtenidos en la muestra de estudiantes?

La interpretación se hace difícil así, por lo que usaremos un gráfico de de barras.

Crearemos un vector de colores

```{r}
colores = c(rep("orange", times = 8),
            rep("gold", times = 8),
            rep("darkgreen", times = 8))
```

Luego usamos `barplot()` para pintar los pesos de la saturación de factores. Usaremos los resultados del análisis con `$`, usando la matriz de saturaciones.

```{r}
barplot(af1$loadings[, 1], col = colores)
```

No se alcanza a representar todos

```{r}
barplot(af1$loadings[, 2], col = colores)
```

Los ítems de las segundas componentes no aparecen

```{r}
barplot(af1$loadings[, 3], col = colores)
```

Los ítems de la primera y la tercera dimensión no contribuyen, pero los ítems de 9 a 16 representa la claridad emocional.

El sentido de las barras dicen la relación con el ítem. 

El Análisis factorial no está recogiendo bien el conjunto de ítems.

Ahora vemos la varianza de los factores. En la matriz de varianzas vemos que la proporción de varianzas es `.518`, la cual podemos verificarla en
```{r}
af1$loadings
```


## 7

Mantenga la solución general anterior (nº de factores y mismas variables), pero realice ahora la rotación **Varimax**. Compruebe si la estructura se verifica en el colectivo de estudiantes de ciencias de la salud y localice las variables correlacionadas con cada factor. Obtenga las conclusiones de las saturaciones realmente informativas.


```{r}
af2 = factanal(tmms, 3, scores = "Bartlett", rotation = "varimax")

af2
```

```{r}
par(mfrow = c(1, 3))
barplot(af2$loadings[, 1], col = colores)
barplot(af2$loadings[, 2], col = colores)
barplot(af2$loadings[, 3], col = colores)
```

Hemos mejorado la estructura factorial del cuestionario. Veamos la proporción de la varianza
```{r}
af2$loadings
```

La varianza absorbida podemos ver que `.518` con 3 variables absorbemos mucho. El total de la información es el mismo, solo que ahora están repartidos de otra forma entre los diferentes factores.

Lo que podemos ver en un gráfico de los dos primeros factores. Con esto estaremos viendo nuestra varianza. 
```{r}
plot(af2$scores[, 1:2], xlab = "Atención", ylab = "Claridad", pch = 19)
```

En el análisis puntual, podemos pintar dos líneas para identificar a los individuos que caen dentro de las dimensiones. Estas líneas estarán en el centro, con las coordenas

```{r}
plot(af2$scores[, 1:2], xlab = "Atención", ylab = "Claridad", pch = 19)
abline(h = 0, v = 0)
```


## 8

A la vista de los resultados anteriores, complete el listado de variables observadas relacionadas con cada uno de los tres factores obtenidos (las 3 subescalas de las que habla la literatura). ¿Existen diferencias?


## 9

¿Está de acuerdo con los nombres que los investigadores han asignado a las escalas del cuestionario TMMS?

# Análisis de Componentes Principales

## 0

`prcomp()` y `princomp()`. No se recomienda la última para bases de datos grandes. Normalmente se usa `prcomp()` en donde irá la data.frame como primer argumento.

Retener más o retener menos no cambia resultados, a diferencia de AF.

```{r}
acp1 = prcomp(tmms)

acp1
```

El esquema es difícil de ver. R llama a la `rotation` a la matriz de `loadings`, de las cargas, no es rotación en sí.

No hay varianza, ni otros resultados. Usemos `summary()` para ver mayor información.

```{r}
summary(acp1)
```

Normalmente vemos la varianza acumulada para decidir con cuántas variables nos quedamos.

En el ACP, tres variables explican más que con el AF.

Haciendo la exploración visual de las cargas.

```{r}
par(mfrow = c(1, 3))
barplot(acp1$rotation[, 1], col = colores)
barplot(acp1$rotation[, 2], col = colores)
barplot(acp1$rotation[, 3], col = colores)
```

Para rotar las cargas del ACP, usamos la función `varimax()`.

```{r}
ACP_rotado = varimax(acp1$rotation)

ACP_rotado$rotmat
```

```{r}
par(mfrow = c(1, 3))
barplot(ACP_rotado$rotmat[, 1], col = colores)
barplot(ACP_rotado$rotmat[, 2], col = colores)
barplot(ACP_rotado$rotmat[, 3], col = colores)
```

La función está rara.

La función `principal()` del paquete `psych`.

```{r}
acp_rot = psych::principal(tmms, nfactors = 3, rotate = "varimax")
acp_rot$loadings
```

`RC1` Corresponde a rotated component, que es el componente principal rotado.

Reparte la información.

Pintanto las cargas...

```{r}
par(mfrow = c(1, 3))
barplot(acp_rot$loadings[, 1], col = colores)
barplot(acp_rot$loadings[, 2], col = colores)
barplot(acp_rot$loadings[, 3], col = colores)
```

El ítem 22 tiene importancia en la primera componente.

En la segunda y tercera componente parecen con la claridad y con la reparación, respectivamente.

## 1


## 2


## 3


## 4




Demostración  de cómo funciona el PCA

```{r}
# install.packages("pixmap")
library(pixmap)

# imagen = read.pnm("imagen.pnm")
# plot(imagen)
# imagen@grey
# 
# a = imagen@grey
# 
# a 
# 
# dim(a)
# 
# k = 25
# 
# pca = prcom(a, center)
```

nerea_gonzalez_garcia@usal.es